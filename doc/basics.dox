namespace Cnes {
/**

\addtogroup basics

\section basics-intro Introduction

A raster is an N-dimensional array of pixels stored in a contiguous one-dimensional container.
The number of axes, or dimension, N, is set at compile time or at runtime.
The raster shape, i.e. the lengths along axes, is set at runtime.
Pixels are located at N-dimensional positions, which convert to 1D indices in the underlying 1D container.

There are other common names for similar concepts, like multidimensional array, ND array, or tensor.
The term raster was chosen to convey some information on the memory contiguity and layout (see next section),
because it is part of the public interface of the library, and not only an implementation detail.

\section basics-memory Memory layout

The pixel ordering scheme is row-major, which means that two adjacent pixels of the same row (along the axis of index 0) are contiguous in memory.
The last pixel of a row immediately precedes the first pixel of the next row,
and the last pixel of the last row of a plane immediately precedes the first pixel of the first row of the next plane.

There is no physical geometry associated with the image.
In particular, no assumption is made on the orientation of the axes.
Graphically, positions are represented from left to right, from bottom to top and from front to back,
but that is only for the purpose of documentation.
The following figure shows the index of each pixel of a raster of shape (4, 3, 2).
It will be used in the remaining of the documentation in code snippets.

\image html diagrams/raster_ordering.svg

\section basics-container Underlying container

The pixel values can be stored in any contiguous container.
The most standard option is a `std::vector` (use this by default).
A raster built on top of a `std::vector` (with default allocator) is of type `VecRaster`.
Here is a simple example to build the `VecRaster` illustrated in the section above
(`std::iota()` is used to fill the 1D container with increasing values):

\code
VecRaster<int, 3> raster({4, 3, 2});
std::iota(raster.begin(), raster.end(), 0); // Assign {0, 1, 2...}
std::cout << "Access by ND position: " << raster[{2, 1, 0}] << std::endl; // 6
std::cout << "Access by 1D index: " << raster[6] << std::endl; // 6
\endcode

It is also possible to dynamically augment any 1D contiguous container
with the raster features (e.g. ND indexing or operations) thanks to the `PtrRaster` class,
in which the underlying container is a raw pointer.
For example:

\code
std::array<int, 4 * 3 * 2> array;
std::iota(array.begin(), array.end(), 0);
PtrRaster<int, 3> raster({4, 3, 2}, array.data());
std::cout << "Access by ND position: " << raster[{2, 1, 0}] << std::endl; // 6
raster *= 2;
std::cout << "Updated value: " << array[6] << std::endl; // 12
\endcode

Last but not least, it is also possible to use your own container,
assuming that it provides the minimal interface, e.g.:

\code
template <typename T>
struct MallocContainer {

  MallocContainer(std::size_t size, T* data) :
      m_size(size), m_container((T*)malloc(m_size * sizeof(T))) {}

  ~MallocContainer() {
    free(m_container);
  }

  std::size_t size() const {
    return m_size;
  }

  const T* data() const {
    return m_container;
  }

  std::size_t m_size;

  T* m_container;
};

template <typename T, Index N>
using MallocRaster = Raster<T, N, MallocContainer<T>>;
\endcode

Which can be used like any other raster:

\code
MallocRaster<int, 3> raster({4, 3, 2});
std::iota(raster.begin(), raster.end(), 0);
std::cout << "Access by ND position: " << raster[{2, 1, 0}] << std::endl; // 6
std::cout << "Access by 1D index: " << raster[6] << std::endl; // 6
\endcode

\section basics-access Element access

As disclosed in the examples above, elements of a raster can be accessed with 1D indices or ND positions.
Indexes are 0-based signed integers, which enables backward indexing with `Raster::at()`, e.g.:

\code
std::cout << "Access by ND position: " << raster[{2, 2, 0}] << std::endl; // 10
std::cout << "Access by 1D index: " << raster[10] << std::endl; // 10
std::cout << "Backward indexing: " << raster.at({-2, -1, 0}) << std::endl; // 10
\endcode

As a standard contiguous container, `Raster` also provides access as iterators,
which are explicitely raw pointers (as opposed to `std::vector` but like `eastl::vector`)
to ensure compiler optimizations are maximal.
Methods `Raster::begin()` and `Raster::end()` enable range for loops
and should be used with standard functions like algorithms.
The following blocks are all functionally equivalent:

\code
// Position
for (Index z = 0; z < raster.length(2); ++z) {
  for (Index y = 0; y < raster.length(1); ++y) {
    for (Index x = 0; x < raster.length(0); ++x) {
      raster[{x, y, z}] *=2;
    }
  }
}

// Position iterator
for (const auto& p : raster.domain()) {
  raster[p] *= 2;
}

// Index
for (std::size_t i = 0; i < raster.size(); ++i) {
  raster[i] *= 2;
}

// Iterator (raw pointer)
for (auto it = raster.begin(); it != raster.end(); ++it) {
  *it *= 2;
}

// Range for loop
for (auto& e : raster) {
  e *= 2;
}

// Algorithm
std::transform(raster.cbegin(), raster.cend(), raster.begin(), [](auto e) { return e * 2; });

// operator*=
raster *= 2;
\endcode

*/
}